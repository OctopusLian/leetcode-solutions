## 思路  

- 1，硬做  
- 2，使用set直接判断重复，时间复杂度O(n * 1)  
- 3，快慢指针，当快慢指针相遇表示有环  


## 题解 - 快慢指针

对于带环链表的检测，效率较高且易于实现的一种方式为使用快慢指针。快指针每次走两步，慢指针每次走一步，如果快慢指针相遇(快慢指针所指内存为同一区域)则有环，否则快指针会一直走到`NULL`为止退出循环，返回`false`.

快指针走到`NULL`退出循环即可确定此链表一定无环这个很好理解。那么带环的链表快慢指针一定会相遇吗？先来看看下图。

![Linked List Cycle](https://raw.githubusercontent.com/billryan/algorithm-exercise/master/shared-files/images/linked_list_cycle.png)

在有环的情况下，最终快慢指针一定都走在环内，加入第`i`次遍历时快指针还需要`k`步才能追上慢指针，由于快指针比慢指针每次多走一步。那么每遍历一次快慢指针间的间距都会减少1，直至最终相遇。故快慢指针相遇一定能确定该链表有环。

1. 异常处理，将`head->next`也考虑在内有助于简化后面的代码。
2. 慢指针初始化为`head`, 快指针初始化为`head`的下一个节点，这是快慢指针初始化的一种方法，有时会简化边界处理，但有时会增加麻烦，比如该题的进阶版。

